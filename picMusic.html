<!DOCTYPE html>
<html>
<body>

<input type="file" id="imgInput" accept="image/*">
<label for="numChunks">Number of Chunks:</label>
<input type="number" id="numChunks" min="1" value="48">
<label for="minDuration">Min Note Duration (ms):</label>
<input type="range" id="minDuration" min="100" max="2500" value="100">
<label for="maxDuration">Max Note Duration (ms):</label>
<input type="range" id="maxDuration" min="100" max="2500" value="500">
<label for="minFreq">Min Frequency (Hz):</label>
<input type="range" id="minFreq" min="20" max="20000" value="20">
<label for="maxFreq">Max Frequency (Hz):</label>
<input type="range" id="maxFreq" min="20" max="20000" value="800">
<label for="restThresh">Rest Threshold:</label>
<input type="range" id="restThresh" min="0" max="100" value="40">
<canvas id="canvas"></canvas>
<button id="playSound" style="display: none;">Play Sound</button>

<script>
    const imgInput = document.getElementById('imgInput');
    const numChunksInput = document.getElementById('numChunks');
    const minDurationInput = document.getElementById('minDuration');
    const maxDurationInput = document.getElementById('maxDuration');
    const restInput = document.getElementById('restThresh');
    const minFreqInput = document.getElementById('minFreq');
    const maxFreqInput = document.getElementById('maxFreq');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let audioCtx, oscillator, intervalId;

    imgInput.addEventListener('change', function() {
        const img = new Image();
        img.onload = function() {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0, img.width, img.height);
            document.getElementById('playSound').style.display = 'block';
        }
        img.src = URL.createObjectURL(this.files[0]);
    });

    document.getElementById('playSound').addEventListener('click', function() {
        if (audioCtx) {
            oscillator.stop();
            clearInterval(intervalId);
        }
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        oscillator = audioCtx.createOscillator();
        oscillator.type = "triangle";
        oscillator.start();
        oscillator.connect(audioCtx.destination);

        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const grayValues = [];
        for (let i = 0; i < imgData.data.length; i += 4) {
            const gray = 0.3 * imgData.data[i] + 0.59 * imgData.data[i + 1] + 0.11 * imgData.data[i + 2];
            grayValues.push((Math.round(gray * 100))/100.0);
        }
        console.log(grayValues)

        const numChunks = parseInt(numChunksInput.value);
        const chunkSize = Math.floor(grayValues.length / numChunks);
        const frequencies = [];
        const durations = [];
        let minGray = 255, maxGray = 0;

        const restThreshold = parseInt(restInput.value);

        for (let i = 0; i < numChunks; i++) {
            let sum = 0, min = 255, max = 0;
            const end = Math.min((i + 1) * chunkSize, grayValues.length);
            for (let j = i * chunkSize; j < end; j++) {
                const gray = grayValues[j];
                sum += gray;
                min = Math.min(min, gray);
                max = Math.max(max, gray);
            }
            const avg = sum / (end - i * chunkSize);
            const freq = parseInt(minFreqInput.value) + avg * (parseInt(maxFreqInput.value) - parseInt(minFreqInput.value)) / 255;
            if (freq > parseInt(maxFreqInput.value)) {
                frequencies.push(0);
            } else {
                // Check if it's a rest based on the threshold
                if (sum / 100000 > restThreshold) {
                    frequencies.push(0); // Rest
                } else {
                    frequencies.push(freq);
                }
            }
            const range = max - min;
            minGray = Math.min(minGray, range);
            maxGray = Math.max(maxGray, range);
            durations.push(range);
        }

        durations.forEach((range, i) => {
            const duration = parseInt(minDurationInput.value) + (range - minGray) * (parseInt(maxDurationInput.value) - parseInt(minDurationInput.value)) / (maxGray - minGray);
            durations[i] = duration;
        });

        oscillator.frequency.value = frequencies[0];
        let i = 1;
        intervalId = setInterval(function() {
            if (i < frequencies.length) {
                oscillator.frequency.value = frequencies[i];
                clearInterval(intervalId);
                intervalId = setInterval(function() {
                    if (i < frequencies.length) {
                        oscillator.frequency.value = frequencies[i];
                        i++;
                    } else {
                        oscillator.stop();
                        clearInterval(intervalId);
                    }
                }, durations[i]);
                i++;
            } else {
                oscillator.stop();
                clearInterval(intervalId);
            }
        }, durations[0]);
    });
</script>

</body>
</html>
